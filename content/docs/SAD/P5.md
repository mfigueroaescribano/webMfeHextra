---
title: Criptografía II - Integridad, firmas y autenticación
type: docs
---
## Tarea 1: firmas electrónicas
En primer lugar creamos una firma con el comando `gpg --gen-key`, y firmaremos un archivo con el comando `gpg --detach-sign archivo`.

Para verificar el archivo y su firma, utilizaremos el comando:
```
gpg --verify firma archivo
```
## Tarea 2: correo seguro con evolution/thunderbird
## Tarea 3: Integridad de ficheros
## Tarea 4: Integridad y autenticidad (apt secure)

## Tarea 5: autentificación - ejemplo SSH
#### Explica los pasos que se producen entre el cliente y el servidor para que el protocolo cifre la información que se transmite? ¿Para qué se utiliza la criptografía simétrica? ¿Y la asimétrica?
El protocolo SSH utiliza tanto criptografía simétrica como asimétrica para garantizar la seguridad en la comunicación entre el cliente y el servidor. Estos son los pasos que se producen:

1. El cliente inicia la conexión al servidor SSH enviando una solicitud de conexión.
Intercambio de identificación y parámetros:

2. El servidor y el cliente intercambian información sobre sus capacidades y parámetros de configuración.

3. Negociación de algoritmos: se realiza una negociación para seleccionar los algoritmos que se utilizarán en la conexión, incluyendo algoritmos para cifrado simétrico, funciones hash, intercambio de claves, etc.

4. Intercambio de claves de sesión (cripografía asimétrica): el cliente y el servidor acuerdan sobre una clave de sesión utilizando criptografía asimétrica. Usualmente, el algoritmo de intercambio de claves utilizado es Diffie-Hellman.

5. Autenticación: en esta fase, se puede realizar la autenticación de las partes. Esto puede involucrar la presentación de credenciales por parte del cliente (como contraseñas o certificados).

6. Generación de la clave de sesión compartida (criptografía simétrica): a partir de la información intercambiada en el paso anterior, ambas partes generan de manera independiente una clave de sesión compartida. Esta clave de sesión será utilizada para cifrar y descifrar los datos durante la sesión.

7. Cifrado de la sesión (criptografía simétrica): a partir de este punto, la conexión SSH utiliza la criptografía simétrica para cifrar los datos durante la transmisión. La clave de sesión compartida se utiliza para este propósito, proporcionando eficiencia y velocidad en el cifrado.

8. Intercambio de mensajes cifrados: Todos los mensajes intercambiados entre el cliente y el servidor, incluyendo comandos, respuestas y otros datos, se cifran utilizando la clave de sesión compartida.

La criptografía simétrica se utiliza para cifrar los datos durante la transmisión debido a su eficiencia. Es más rápida que la criptografía asimétrica, por lo que es ideal para cifrar grandes cantidades de datos. Sin embargo, la criptografía asimétrica se utiliza en la fase de intercambio de claves para asegurar que las claves de sesión compartida se generen de forma segura y sin necesidad de intercambiar claves directamente, lo que sería menos seguro. La combinación de ambos tipos de criptografía en SSH aprovecha las fortalezas de cada uno para proporcionar un entorno de comunicación seguro y eficiente.

#### Explica los dos métodos principales de autentificación: por contraseña y utilizando un par de claves públicas y privadas.
- **Autenticación por contraseña:** el usuario inicia una conexión SSH proporcionando un nombre de usuario y contraseña, y son enviados al servidor. El servidor compara la contraseña ingresada con la almacenada para el usuario. Este método es sencillo aunque la seguridad depende de la complejidad y robustez de la contraseña, y puede ser vulnerable a ataques de fuerza bruta o de suplantación de identidad si estas son débiles.

- **Autenticación por par de claves:** el usuario genera un par de claves. La clave pública se inyecta en el servidor SSH y se asocia con el nombre de usuario correspondiente. Al iniciarse la conexión SSH, el cliente debe hacerlo con su clave privada para demostrar la identidad. El servidor utiliza la clave pública asociada al usuario para verificar la autenticidad de la clave privada del cliente. Este método proporciona un alto nivel de seguridad, superior al método de autenticación por contraseña (por ejemplo es resistente a los ataques por fuerza bruta). Además también permite el acceso a un servidor sin necesidad de ingresar una contraseña cada vez que se establece la conexión.

#### En el cliente, ¿para que sirve el contenido que se guarda en el fichero `~/.ssh/know_hosts`?
Este archivo almacena los fingerprints de las claves públicas de los hosts remotos a los que el cliente se ha conectado anteriormente. Cuando el cliente se va a conectar a un host remoto, la clave pública de ese host se almacena en este archivo. Una vez almacenada en el cliente, en la próxima conexión se vuelve a calcular el fingerprint del host remoto y se compara con el que ya estaba almacenado de anteriores conexiones. Si la huella digital coincide con una entrada existente, se considera que el host es auténtico y la conexión procede sin problemas. Si la huella digital no coincide, el cliente emite una advertencia de posible ataque de "man-in-the-middle" (intermediario malicioso) porque la clave pública del host remoto ha cambiado.

#### ¿Qué significa este mensaje que aparece la primera vez que nos conectamos a un servidor?
```
 $ ssh debian@172.22.200.74
 The authenticity of host '172.22.200.74 (172.22.200.74)' can't be established.
 ECDSA key fingerprint is SHA256:7ZoNZPCbQTnDso1meVSNoKszn38ZwUI4i6saebbfL4M.
 Are you sure you want to continue connecting (yes/no)? 
```
Este mensaje aparece la primera vez que nos conectamos a un host ya que intenta comparar el fingerprint almacenado en el archivo `know_hosts` con el que calcula automáticamente del host remoto, pero al ser la primera conexión no encuentra esa entrada.

#### En ocasiones cuando estamos trabajando en el cloud, y reutilizamos una ip flotante nos aparece este mensaje
```
 $ ssh debian@172.22.200.74
 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 @    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
 Someone could be eavesdropping on you right now (man-in-the-middle attack)!
 It is also possible that a host key has just been changed.
 The fingerprint for the ECDSA key sent by the remote host is
 SHA256:W05RrybmcnJxD3fbwJOgSNNWATkVftsQl7EzfeKJgNc.
 Please contact your system administrator.
 Add correct host key in /home/jose/.ssh/known_hosts to get rid of this message.
 Offending ECDSA key in /home/jose/.ssh/known_hosts:103
   remove with:
   ssh-keygen -f "/home/jose/.ssh/known_hosts" -R "172.22.200.74"
 ECDSA host key for 172.22.200.74 has changed and you have requested strict checking.
```
Esto es precisamente lo que se explica en la descripción del archivo `know_hosts`. Nos estamos conectando a un host remoto que previamente teníamos su fingerprint almacenada en este archivo, pero al comparar la actual del host remoto con la que teníamos almacenada estas no coinciden, por lo que nos manda la alerta.

#### ¿Qué guardamos y para qué sirve el fichero en el servidor `~/.ssh/authorized_keys`?
En este archivo es donde se almacenan las claves públicas de los clientes remotos que desean acceder al servidor. Al realizarse la conexión a usuario1 por ejemplo, la clave pública del cliente debe estar presente en el archivo `authorized_keys` de usuario1 para que tenga permisos de acceso a esa sesión. La seguridad de este archivo es importante, y sus permisos típicos son 600: de lectura y escritura solo para el propietario.